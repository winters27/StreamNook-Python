name: Build and Release

# Quote "on" because YAML 1.1 treats bare "on" as boolean
"on":
  push:
    branches: [ "main" ]
  workflow_dispatch: {}   # allow manual runs

permissions:
  contents: write    # needed for creating releases/tags
  actions: read
  checks: read

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build:
    name: Build Windows EXE and create Release
    runs-on: windows-latest

    steps:
      - name: Checkout (full history for tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure tags available
        run: |
          git fetch --tags --force

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: |
            requirements.txt

      - name: Install build deps and UPX
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller
          choco install upx --no-progress
          echo "UPX_DIR=C:\ProgramData\chocolatey\lib\upx\tools" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append


      - id: version
        name: Determine next version from tags and commits
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          
          Write-Host "=== Version Detection ==="
          Write-Host "Current commit: $(git rev-parse HEAD)"
          Write-Host ""
          
          # Get all version tags
          $allTags = @(git tag --list "v*" --sort=-v:refname)
          Write-Host "All existing tags: $($allTags -join ', ')"
          
          # Get the latest tag
          $latestTag = $allTags | Select-Object -First 1
          
          if (-not $latestTag) {
              Write-Host "No existing tags found, starting at v1.0.0"
              $next = "v1.0.0"
          } else {
              Write-Host "Latest tag: $latestTag"
              
              # Parse version
              if ($latestTag -match "^v(\d+)\.(\d+)\.(\d+)$") {
                  $maj = [int]$Matches[1]
                  $min = [int]$Matches[2]
                  $pat = [int]$Matches[3]
                  
                  # Check commit messages for version bump type
                  $recentCommits = git log -n 5 --pretty=%B
                  
                  if ($recentCommits -match 'BREAKING CHANGE' -or $recentCommits -match 'release: major') {
                      $maj++; $min = 0; $pat = 0
                      Write-Host "Detected MAJOR version bump"
                  } elseif ($recentCommits -match '^feat' -or $recentCommits -match 'release: minor') {
                      $min++; $pat = 0
                      Write-Host "Detected MINOR version bump"
                  } else {
                      $pat++
                      Write-Host "Detected PATCH version bump (default)"
                  }
                  
                  $next = "v{0}.{1}.{2}" -f $maj, $min, $pat
              } else {
                  Write-Host "WARNING: Could not parse $latestTag, defaulting to v1.0.0"
                  $next = "v1.0.0"
              }
          }
          
          # Final check: does this tag already exist?
          $tagExists = git tag --list $next
          if ($tagExists) {
              Write-Host "ERROR: Tag $next already exists!"
              Write-Host "Tags that exist: $($allTags -join ', ')"
              Write-Host "Cannot create duplicate tag. Please delete the existing tag or adjust version."
              exit 1
          }
          
          Write-Host ""
          Write-Host "âœ“ Will create version: $next"
          Write-Host "====================" 
          
          echo "NEXT_VERSION=$next" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "NEXT_VERSION_NO_V=$($next.TrimStart('v'))" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "version=$next" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Build application (PowerShell)
        shell: pwsh
        run: |
          ./build.ps1 -NonInteractive -VersionOverride $env:NEXT_VERSION_NO_V -UpxDir $env:UPX_DIR

      - name: Upload build as artifact (for debugging/retention)
        uses: actions/upload-artifact@v4
        with:
          name: StreamNook-${{ env.NEXT_VERSION }}-exe
          path: ./dist/StreamNook.exe
          if-no-files-found: error
          retention-days: 14

      - id: notes
        name: Create release notes from commits
        shell: pwsh
        run: |
          $prev = (git tag --list "v*" --sort=-v:refname | Select-Object -First 1)
          if (-not $prev) { $prev = (git rev-list --max-parents=0 HEAD | Select-Object -First 1) }
          $lines = git log "$prev"..HEAD --pretty=format:"* %s (%h)"
          # escape for GitHub output (percent, LF, CR)
          $lines = $lines -replace '%','%25' -replace "`n","%0A" -replace "`r","%0D"
          echo "body=$lines" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Create tag
        shell: pwsh
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Double-check tag doesn't exist before creating
          $tagExists = git tag --list $env:NEXT_VERSION
          if ($tagExists) {
              Write-Error "Tag $env:NEXT_VERSION already exists!"
              exit 1
          }
          
          git tag $env:NEXT_VERSION
          git push origin $env:NEXT_VERSION

      # Create the GitHub Release and upload the EXE in one step
      - name: Publish GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          name: StreamNook ${{ env.NEXT_VERSION }}
          tag_name: ${{ env.NEXT_VERSION }}
          body: |
            ### Changes
            ${{ steps.notes.outputs.body }}
          files: |
            ./dist/StreamNook.exe
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}