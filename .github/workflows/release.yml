name: Build and Release

# Quote "on" because YAML 1.1 treats bare "on" as boolean
"on":
  push:
    branches: [ "main" ]
  workflow_dispatch: {}   # allow manual runs

permissions:
  contents: write    # needed for creating releases/tags
  actions: read
  checks: read

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build:
    name: Build Windows EXE and create Release
    runs-on: windows-latest

    steps:
      - name: Checkout (full history for tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure tags available
        run: |
          git fetch --tags --force

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: |
            requirements.txt

      - name: Install build deps and UPX
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller
          choco install upx --no-progress
          echo "UPX_DIR=C:\ProgramData\chocolatey\lib\upx\tools" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append


      - id: version
        name: Determine next version from tags and commits
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          
          # Get current commit hash
          $currentCommit = git rev-parse HEAD
          Write-Host "Current commit: $currentCommit"
          
          # Get all tags and sort them
          $latestTag = (git tag --list "v*" --sort=-v:refname | Select-Object -First 1)
          Write-Host "Latest tag found: $latestTag"
          
          if (-not $latestTag) { 
              $latestTag = "v0.0.0" 
              Write-Host "No existing tags, starting from v0.0.0"
          }

          # Get the commit hash of the latest tag
          $tagCommit = git rev-list -n 1 $latestTag 2>$null
          if ($tagCommit) {
              Write-Host "Latest tag ($latestTag) points to commit: $tagCommit"
          }

          # Check if current commit already has this tag
          if ($tagCommit -eq $currentCommit) {
              Write-Host "Current commit is already tagged as $latestTag"
              Write-Host "A workflow trigger should mean there's a new commit. Checking..."
              
              # List recent commits for debugging
              Write-Host "Recent commits:"
              git log --oneline -n 5
              
              # This shouldn't happen with push triggers, but if it does, skip
              Write-Host "ERROR: Current commit already tagged. This workflow should only run on new commits."
              echo "SKIP_BUILD=true" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
              exit 0
          }

          # Check if the tag is an ancestor of HEAD (i.e., HEAD is descended from the tag)
          $isAncestor = git merge-base --is-ancestor $latestTag HEAD 2>&1
          $isAncestorResult = $LASTEXITCODE
          
          if ($isAncestorResult -ne 0) {
              Write-Host "WARNING: Tag $latestTag is not an ancestor of current HEAD"
              Write-Host "This means the tag is on a different branch or history was rewritten"
              Write-Host "Will create new version anyway since this is a push trigger"
              $commits = @("dummy") # Force a version bump
          } else {
              # Tag is an ancestor, check for new commits
              $commits = git log $latestTag..HEAD --oneline 2>&1
              Write-Host "Commits since $latestTag : $($commits.Count) commit(s)"
              
              if (-not $commits -or $commits.Count -eq 0) {
                  Write-Host "No new commits detected - but this shouldn't happen on a push trigger"
                  Write-Host "This is likely because current commit is already tagged"
                  Write-Host "Skipping build to prevent duplicate release"
                  echo "SKIP_BUILD=true" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
                  exit 0
              }
          }
          
          Write-Host "✓ Proceeding with build"

          # Get commit messages for bump detection
          $commitMessages = git log $latestTag..HEAD --pretty=%B 2>$null
          if (-not $commitMessages) {
              # Fallback: just use recent commit messages
              $commitMessages = git log -n 5 --pretty=%B
          }
          
          Write-Host "Analyzing commits for version bump..."
          
          $bump = "patch" # Default
          if ($commitMessages -match 'BREAKING CHANGE' -or $commitMessages -match '## release: major') {
              $bump = "major"
              Write-Host "Detected MAJOR change"
          } elseif ($commitMessages -match '^feat' -or $commitMessages -match '## release: minor') {
              $bump = "minor"
              Write-Host "Detected MINOR change"
          } else {
              Write-Host "Detected PATCH change (default)"
          }

          if ($latestTag -match "^v(\d+)\.(\d+)\.(\d+)$") {
            $maj = [int]$Matches[1]; $min = [int]$Matches[2]; $pat = [int]$Matches[3]
          } else {
            $maj = 0; $min = 0; $pat = 0
          }

          switch ($bump) {
            "major" { $maj++; $min = 0; $pat = 0 }
            "minor" { $min++; $pat = 0 }
            default { $pat++ }
          }

          $next = "v{0}.{1}.{2}" -f $maj, $min, $pat
          
          # Check if this tag already exists
          $tagExists = git tag --list $next
          if ($tagExists) {
              Write-Host "WARNING: Tag $next already exists - incrementing patch version"
              $pat++
              $next = "v{0}.{1}.{2}" -f $maj, $min, $pat
          }
          
          echo "NEXT_VERSION=$next" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "NEXT_VERSION_NO_V=$($next.TrimStart('v'))" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "version=$next" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          Write-Host "✓ Next version will be: $next"

      - name: Build application (PowerShell)
        if: env.SKIP_BUILD != 'true'
        shell: pwsh
        run: |
          ./build.ps1 -NonInteractive -VersionOverride $env:NEXT_VERSION_NO_V -UpxDir $env:UPX_DIR

      - name: Upload build as artifact (for debugging/retention)
        if: env.SKIP_BUILD != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: StreamNook-${{ env.NEXT_VERSION }}-exe
          path: ./dist/StreamNook.exe
          if-no-files-found: error
          retention-days: 14

      - id: notes
        name: Create release notes from commits
        if: env.SKIP_BUILD != 'true'
        shell: pwsh
        run: |
          $prev = (git tag --list "v*" --sort=-v:refname | Select-Object -First 1)
          if (-not $prev) { $prev = (git rev-list --max-parents=0 HEAD | Select-Object -First 1) }
          $lines = git log "$prev"..HEAD --pretty=format:"* %s (%h)"
          # escape for GitHub output (percent, LF, CR)
          $lines = $lines -replace '%','%25' -replace "`n","%0A" -replace "`r","%0D"
          echo "body=$lines" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Create tag
        if: env.SKIP_BUILD != 'true'
        shell: pwsh
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Double-check tag doesn't exist before creating
          $tagExists = git tag --list $env:NEXT_VERSION
          if ($tagExists) {
              Write-Error "Tag $env:NEXT_VERSION already exists!"
              exit 1
          }
          
          git tag $env:NEXT_VERSION
          git push origin $env:NEXT_VERSION

      # Create the GitHub Release and upload the EXE in one step
      - name: Publish GitHub Release
        if: env.SKIP_BUILD != 'true'
        uses: softprops/action-gh-release@v2
        with:
          name: StreamNook ${{ env.NEXT_VERSION }}
          tag_name: ${{ env.NEXT_VERSION }}
          body: |
            ### Changes
            ${{ steps.notes.outputs.body }}
          files: |
            ./dist/StreamNook.exe
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}